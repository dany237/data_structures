{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to the Danielle Data Structures Documentation","text":"<p>This package implements core data structures in Python:</p> <ul> <li>Array</li> <li>Linked List</li> <li>Circular Linked List</li> <li>Stack</li> <li>Queue</li> <li>Tree</li> <li>Graph</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>To install the package:</p> <p>```bash pip install danielle</p>"},{"location":"arrays/","title":"Array Class Documentation","text":"<p>The <code>Array</code> class implements a dynamic array in Python. It supports various array operations such as appending, inserting, removing elements, and accessing elements by index. The class is a custom implementation and offers flexibility to manipulate data in a simple and intuitive manner.</p>"},{"location":"arrays/#class-array","title":"Class: <code>Array</code>","text":""},{"location":"circular_linked_list/","title":"Circular Linked List","text":""},{"location":"circular_linked_list/#overview","title":"Overview","text":"<p>A Circular Linked List is a variation of the standard linked list in which the last node of the list points back to the first node, forming a circle. Unlike a linear linked list, where the last node's <code>next</code> pointer is <code>None</code>, the circular linked list provides a way to loop through the entire list continuously, making it suitable for certain applications like round-robin scheduling or circular buffers.</p>"},{"location":"circular_linked_list/#structure","title":"Structure","text":"<p>Each node in the circular linked list contains: - Data: The value stored in the node. - Next: A reference to the next node in the list. For the last node, this <code>next</code> pointer points back to the head node, completing the circle.</p>"},{"location":"contributing/","title":"Contributing","text":""},{"location":"contributing/#contributing","title":"Contributing","text":"<p>Thank you for considering contributing to the <code>Queue</code> class! To contribute, please follow these steps:</p>"},{"location":"contributing/#1-fork-and-clone-the-repository","title":"1. Fork and Clone the Repository","text":"<p>Fork the repository on GitHub and clone it to your local machine:</p> <p>```bash git clone https://github.com/your-username/queue-class.git</p>"},{"location":"doubly_linked_list/","title":"Doubly Linked List","text":""},{"location":"doubly_linked_list/#overview","title":"Overview","text":"<p>A Doubly Linked List is a type of linked list where each node has two pointers: - Next Pointer: Points to the next node in the list. - Previous Pointer: Points to the previous node in the list.</p> <p>This allows traversal in both directions: from the head to the tail and from the tail to the head. Unlike singly linked lists, where traversal is only possible in one direction, doubly linked lists offer more flexibility for efficient insertions and deletions at both ends and in the middle.</p>"},{"location":"doubly_linked_list/#structure","title":"Structure","text":"<p>Each node in a doubly linked list contains: - Data: The value stored in the node. - Prev: A reference to the previous node in the list. - Next: A reference to the next node in the list.</p>"},{"location":"graph/","title":"Graph Class Documentation","text":"<p>The <code>Graph</code> class implements an undirected or directed graph using an adjacency list. It supports basic graph operations such as adding/removing vertices and edges, as well as performing Depth-First Search (DFS) and Breadth-First Search (BFS).</p>"},{"location":"graph/#class-graph","title":"Class: <code>Graph</code>","text":""},{"location":"graph/#constructor-__init__directedfalse","title":"Constructor: <code>__init__(directed=False)</code>","text":"<p>The constructor initializes the graph with an empty adjacency list. By default, the graph is undirected, but you can specify a directed graph by setting the <code>directed</code> argument to <code>True</code>.</p> <p>```python class Graph:     def init(self, directed=False):         self.adj_list = {}         self.directed = directed</p>"},{"location":"license/","title":"License","text":""},{"location":"license/#mit-license-summary","title":"MIT License Summary","text":"<ul> <li>You can freely use, modify, and distribute the code.</li> <li>You must include the original copyright and license notice in any distributed software.</li> <li>The software is provided \"as-is,\" without any warranties.</li> </ul> <p>For full details, please refer to the LICENSE file in the repository.</p>"},{"location":"linked_list/","title":"Linked List","text":""},{"location":"linked_list/#overview","title":"Overview","text":"<p>A Linked List is a linear data structure where each element (node) contains data and a reference (link) to the next node in the sequence. Linked lists are dynamic, meaning their size can grow or shrink during program execution. They are efficient for insertions and deletions compared to arrays because nodes can be added or removed without the need to shift other elements.</p>"},{"location":"linked_list/#structure","title":"Structure","text":"<p>Each node in a singly linked list contains: - Data: The value stored in the node. - Next: A reference (pointer) to the next node in the list.</p>"},{"location":"queue/","title":"Queue Class Documentation","text":"<p>The <code>Queue</code> class represents a queue data structure using a list. It supports typical queue operations such as enqueue, dequeue, peek, and checking if the queue is empty.</p>"},{"location":"queue/#class-queue","title":"Class: <code>Queue</code>","text":""},{"location":"queue/#constructor-__init__self","title":"Constructor: <code>__init__(self)</code>","text":"<p>The constructor initializes the queue with an empty list of items.</p> <p>```python class Queue:     def init(self):         self.items = []</p>"},{"location":"stack/","title":"Stack","text":""},{"location":"stack/#overview","title":"Overview","text":"<p>A Stack is a linear data structure that follows the Last In, First Out (LIFO) principle. This means that the last element added to the stack is the first one to be removed. It is often compared to a stack of plates where you add plates to the top and also remove them from the top.</p>"},{"location":"stack/#structure","title":"Structure","text":"<p>A stack consists of the following: - Push: Adds an element to the top of the stack. - Pop: Removes and returns the element from the top of the stack. - Top: Returns the top element of the stack without removing it. - isEmpty: Checks if the stack is empty. - Display: Shows the contents of the stack.</p>"},{"location":"tree/","title":"Binary Search Tree (BST)","text":""},{"location":"tree/#overview","title":"Overview","text":"<p>A Binary Search Tree (BST) is a binary tree in which each node has at most two children, referred to as the left and right children. For any node, all values in its left subtree are smaller, and all values in its right subtree are greater. This property makes the BST efficient for search, insertion, and deletion operations.</p>"},{"location":"tree/#structure","title":"Structure","text":"<p>Each node in a BST consists of: - Data: The value stored in the node. - Left: A reference to the left child (subtree with smaller values). - Right: A reference to the right child (subtree with larger values).</p>"},{"location":"tree/#example","title":"Example:","text":""},{"location":"tree/#binary-search-tree-bst_1","title":"Binary Search Tree (BST)","text":""},{"location":"tree/#overview_1","title":"Overview","text":"<p>A Binary Search Tree (BST) is a binary tree in which each node has at most two children, referred to as the left and right children. For any node, all values in its left subtree are smaller, and all values in its right subtree are greater. This property makes the BST efficient for search, insertion, and deletion operations.</p>"},{"location":"tree/#structure_1","title":"Structure","text":"<p>Each node in a BST consists of: - Data: The value stored in the node. - Left: A reference to the left child (subtree with smaller values). - Right: A reference to the right child (subtree with larger values).</p>"},{"location":"tree/#example_1","title":"Example:","text":"<pre><code>10\n</code></pre> <p>/  \\   5    15  / \\   / \\ 3  7 12  20</p>"}]}